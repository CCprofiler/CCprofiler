#' Find Feature subunits that correlate well in on hypothesis feature but not in another. 
#'
#' @param traces.obj An object of type \code{traces.obj}.
#' @param features An object of type \code{complexFeatures} as generated by the 
#'  findComplexFeatures function.
#' @param score_weights Vector of length 2 with the weight of corrella
#' @details The mean correlation and Intensity(Area under the curve) of all detected subunits is calculated. 
#' @return A list of Proteins/Protein Complexes with calculated difference scores:
#'         \itemize{
#'          \item \code{corr_diff} Pairwise difference of the mean trace-correlation between all features.
#'          \item \code{intensity_diff} Pairwise difference of the trace-intensity between all features.
#'          \item \code{combined_score} Weighted sum of the above differences.
#'          \item \code{smallToLarge} Logical. Is the more intense trace in the smaller Feature?
#'          \item \code{comparisons} Which Features are compared in which column of the results.
#'         }
#' @import data.table
#' @export

calculateFeatureDiffScores <- function(traces.obj, features, score_weights = c(1,1)){
  
  trace_corr <- extractCorrelation(traces.obj = traces.obj, features.obj = features)
  
  diff <-
    lapply(names(trace_corr), function(feature){
      comparisons <- combn(seq_len(length(trace_corr[[feature]])),m=2)
      # Get correlation difference (set negative correlations to 0)
      corr <- apply(comparisons,2, function(x){
        b <-sapply(seq_along(trace_corr[[feature]][[1]]$corr), function(i){
          abs(trace_corr[[feature]][[x[1]]]$corr[i] * (trace_corr[[feature]][[x[1]]]$corr[i] > 0) -
                trace_corr[[feature]][[x[2]]]$corr[i] * (trace_corr[[feature]][[x[2]]]$corr[i] > 0))
        })
      })
      # # Get rank difference
      # rnk <- apply(comparisons,2, function(x){
      #   b <-sapply(seq_along(trace_corr[[feature]][[1]]$corr), function(i){
      #     abs(trace_corr[[feature]][[x[1]]]$rank[i]-trace_corr[[feature]][[x[2]]]$rank[i])
      #   })
      # })
      # rnk <- rnk/length(rnk)
      # Get intensity difference
      int <- apply(comparisons,2, function(x){
        b <-sapply(seq_along(trace_corr[[feature]][[1]]$corr), function(i){
          abs(trace_corr[[feature]][[x[1]]]$intensities[i]/max(trace_corr[[feature]][[x[1]]]$intensities) -
                trace_corr[[feature]][[x[2]]]$intensities[i]/max(trace_corr[[feature]][[x[2]]]$intensities))
        })
      })
      # Get if intensity difference is increasing from small to large
      smallToLarge <- apply(comparisons,2, function(x){
        b <-sapply(seq_along(trace_corr[[feature]][[1]]$corr), function(i){
          (trace_corr[[feature]][[x[1]]]$intensities[i] - trace_corr[[feature]][[x[2]]]$intensities[i]) *
            (max(trace_corr[[feature]][[x[1]]]$intensities) - max(trace_corr[[feature]][[x[2]]]$intensities)) < 0
        })
      })
      
      combined_score <- score_weights[1] * corr + score_weights[2] * int
      list(corr_diff = corr, intensity_diff = int, combined_score = combined_score,
           smallToLarge =smallToLarge, comparisons = comparisons)
    })
  
  names(diff) <- names(trace_corr)
  return(diff)
}

#' Plot a density Distribution plot of the calculated score (For analysis purposes) 
#'
#' @param diff DiffScore list as produced by the function calculateFeatureDiffScores
#' @param quantile_cutoff A line is drawn at this cutoff in the plot. Suppressed by NULL.
#' @param score_weights Vector of length 2 with the weight of corrella
#' @details The mean correlation and Intensity(Area under the curve) of all detected subunits is calculated. 
#' @return A density Histogram of the calculated difference scores.
#' @import data.table
#' @import ggplot2
#' @import reshape2
#' @export

plotDiffScoreDistribution <- function(diff, quantile_cutoff = 0.95){
  
  combined_scores <- as.data.frame(do.call("rbind",sapply(diff, function(x) sapply(1:3, function(i) x[[i]]))))
  names(combined_scores) <- names(diff[[1]])[1:3]

  outlier_cutoff <- quantile(combined_scores$combined_score,quantile_cutoff)
  # library(ggplot2)
  # library(reshape2)
  plot_table <- melt(combined_scores)
  p <- ggplot(plot_table, aes(x = value, fill = variable)) +
    geom_density(alpha = 0.6)
  if(!is.null(quantile_cutoff)){
    p <- p + geom_vline(xintercept = outlier_cutoff, lty = "dashed", colour = "red")
  }
  print(p)
}




extractCorrelation <- function(traces.obj, features.obj,
                                    perturb.cutoff = "5%"){
  
  if(class(features.obj)[1] == "complexFeatures"){
    features <- resultsToTable(features.obj)
  } else if(!is.data.table(features.obj)){
    stop("features.obj must be of type 'complexFeatures' or 'data.table'")
  } else {
    features <- features.obj
  }
  
  if(!("peak_corr" %in% colnames(features))) stop("No column peak_corr found. peak_corr must be
                                                  calculated with calculateFeatureCorrelation() first!")
  # Keep only features that have 2 or more subunits (otherwise no corr. possible)
  features <- subset(features, features$n_subunits_detected >=2)
  feature.names <- features$protein_id
  
  # Keep only Hypotheses with two or more detected features
  feature.names <- unique(feature.names[duplicated(feature.names)])
  
  # Helper function to subset traces obj.
  getIntensityMatrix <- function(trace.obj) {
    fragment.ids <- trace.obj$traces$id
    intensity.mat <- as.matrix(subset(trace.obj$traces,
                                      select=-id))
    rownames(intensity.mat) <- fragment.ids
    intensity.mat
  }
  # Impute noise for missing intensity measurements globally for all traces alternative
  trace.mat.imputed <- getIntensityMatrix(traces.obj)
  n.zero.entries <- sum(trace.mat.imputed == 0) # number of ZERO values in matrix
  measure.vals <- trace.mat.imputed[trace.mat.imputed != 0]
  if(class(perturb.cutoff) == "character"){
    qt <- as.numeric(gsub("%","",perturb.cutoff))/100
    perturb.cutoff <- quantile(measure.vals, qt)
  }
  set.seed(123) # set seed to always get same results
  trace.mat.imputed[trace.mat.imputed == 0] <- sample(1:perturb.cutoff,size = n.zero.entries,
                                                      replace = TRUE)
  # Calculate correlation in Peak boundaries for every detected trace
  
  trace.corr<- lapply(feature.names, function(hyp){
    
    features.hyp <- features[features$protein_id == hyp,]
    subunits.union <- unique(do.call("c",strsplit(features.hyp$subunits_detected,";")))
    n.subunits <- length(subunits.union)
    if(n.subunits>1){
      onehyp <- apply(features.hyp,1, function(x){
        
        bound_left <- as.numeric(x["left_pp"])
        bound_right <- as.numeric(x["right_pp"])
        pk <- as.numeric(x["peak_corr"])
        traces.feature <- trace.mat.imputed[subunits.union,bound_left:bound_right]
        # Pairwise pearson correlation, Traces with all the same value (e.g. 0 everywhere)
        # cannot be correlated. Should we impute noise?
        corr.x <- cor(t(traces.feature))
        # get mean correlation for every subunit normalized by the mean corr of all subunits
        corr.x.subunits <- (colSums(corr.x)-1) / ((n.subunits-1)) #*pk to normalize?
        # get intensity of every trace within peak boundaries
        intensities <- rowSums(traces.feature)
        rank <- rank(intensities)
        list(corr = corr.x.subunits, intensities = intensities, rank =rank,total_intensity = as.numeric(x["area"]))
      })
      
      # colnames(onehyp$corr) <- paste0("Apex",features.hyp$apex)
      names(onehyp) <- paste0("Apex",features.hyp$apex)
      
    } else onehyp <- NULL
    onehyp
  })
  
  names(trace.corr) <- feature.names
  
  # diff <- lapply(trace.corr, function(x){
  #   abs(x[,1]-x[,2])
  # })
  trace.corr <- trace.corr[!sapply(trace.corr,is.null)]
  return(trace.corr)
}

#' Plot Multiple Proteins and highlight differential Traces  
#'
#' @param proteinIDs Character vector of proteins to plot, 
#' matching with names in the protein_id column of the features table.
#' @param traces An object of type \code{traces.obj}.
#' @param features An object of type \code{complexFeatures} as generated by the 
#'  findComplexFeatures function.
#' @param highlight_cutoff Traces with this combined_diff score or higher are highlighted.
#' @param outfile_name Name of the pdf to be printed
#' @param pdf \code{boolean} Wether to print a pdf file or to console
#' @param diff_scores list of diff_scores produced by calculateFeatureDiffScores
#' @param plot_sequence \code{boolean} Wether to also print the protein sequence
#' @param ProteinFasta A path to a fasta file with protein sequences or an \code{AAStringSet} object.
#' This is ignored if \code{plot_sequence} is set to \code{FALSE} and reqired if \code{TRUE}.
#' @import Biostrings
#' @import msa
#' @export

plotDifferentialTraces <- function(proteinIDs, diff_scores, features, traces, highlight_cutoff = 1,
                                   outfile_name = "Differentially_behaving_Traces.pdf", pdf = TRUE,
                                   plot_sequence = FALSE, ProteinFasta = NULL){
  if(!plot_sequence){
    if(pdf){
      pdf(outfile_name,height=5,width=10)
      for(proteinID in proteinIDs){
        top <- which(diff_scores[[proteinID]]$combined_score >= highlight_cutoff, arr.ind = TRUE)
        if(length(top)>0){ 
          outlier_pep <- rownames(top)
          p <- plot.proteinFeatures(features, traces, proteinID, plot_in_complex_estimate = T,
                                    plot_monomer = T, highlight = outlier_pep, legend = T)
          
        }
      }
      dev.off()
    }else{
      for(proteinID in proteinIDs){
        top <- which(diff_scores_sorted[[proteinID]]$combined_score >= highlight_cutoff, arr.ind = TRUE)
        if(length(top)>0){ 
          outlier_pep <- rownames(top)
          print(plot.proteinFeatures(proteinFeatures_peakcorr05_compl05,pepTraces,proteinID, plot_in_complex_estimate = T,
                                     plot_monomer = T, highlight = outlier_pep, legend = T))
          
        }
      }
    }
  }else{
    
    if(class(ProteinFasta) == "character"){
      sequences <- readAAStringSet(filepath = ProteinFasta)
    }else if(class(ProteinFasta) == "AAStringSet"){
      sequences <- ProteinFasta
    }else{
      stop("Input ProteinFasta must be of type character (Filepath to fasta file) or AAStringSet")
    }
    if(grepl("^>ENSG", names(sequences[1]))){
      names(sequences) <- gsub("^>|-.*|\\|.*","", names(sequences))
    }else{
      names(sequences) <- sapply(strsplit(names(sequences), split = "\\|"), "[", 2)
    }
    
    # knit("Y:/Master_Project/results/2017-02-14/plotProteinFeaturesSequence.Rmd", envir = parent.frame())
    # pandoc("Y:/Master_Project/results/2017-02-14/plotProteinFeaturesSequence.md", format = "pdf")
    if(!grepl("\\.pdf$", outfile_name)) outfile_name <- paste0(outfile_name,".pdf")
    rmarkdown::render(input = base::system.file("R/plotProteinFeaturesSequence.Rmd",package = "SECprofiler"),
                      output_file = outfile_name, output_dir = getwd(), knit_root_dir = getwd())
    
  }
  # plotproteinFeaturesSequence <- function(proteinFeatures,pepTraces,proteinIDs, ProteinFasta, output){
  # }
  
}
