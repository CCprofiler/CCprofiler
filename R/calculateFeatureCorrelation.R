#' A helper function to calculate correlation within peak boundaries after Feature 
#' detection with sliding window.
#'
#' @param traces.obj An object of type \code{traces.obj}.
#' @param features An object of type \code{complexFeatures} as generated by the 
#'  findComplexFeatures function.
#' @param toTable wether the output should be in table format, or in the original \code{complexFeatures} format.
#' @details The mean correlation of all detected subunits and total peak area is calculated.
#'          This is a helper function for FindComplexFeatures.
#' @return An List containing a features table. Every Feature now has an added peak_corr and area value.
#' @export


calculateFeatureCorrelation <- function(trace.mat, features.obj,
                                          toTable = FALSE){
    
    mean.corr <- apply(features.obj$features,1, function(x){
      bound_left <- x["left_pp"]
      bound_right <- x["right_pp"]
      subunits <- strsplit(x["subgroup"], split = ";")
      traces.feature <- trace.mat[subunits[[1]],bound_left:bound_right]
      # Pairwise pearson correlation, Traces with all the same value (e.g. 0 everywhere)
      # cannot be correlated. Should we impute noise?
      corr.x <- cor(t(traces.feature))
      corr.x <- corr.x[upper.tri(corr.x)]
      c(mean(corr.x,na.rm = TRUE),
      sum(traces.feature))
    })
    features.obj$features$peak_corr <- mean.corr[1,]
    features.obj$features$area <- mean.corr[2,]
    
    return(features.obj)
    
}


  
  
  
  
