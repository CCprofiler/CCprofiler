---
title: "Introduction to the PCprofiler package"
author: "Isabell Bludau, Max Frank"
date: '`r Sys.Date()`'
output:
  html_document:
    depth: 3
    number_sections: yes
    theme: united
    toc: yes
  pdf_document:
    toc: yes
vignette: |
  %\VignetteIndexEntry{Introduction to the PCprofiler package} %\VignetteEngine{knitr::rmarkdown} %\VignetteEncoding{UTF-8}
---

# Overview
Here we show the basic steps for performing the analysis of PCP-MS datasets with PCprofiler. PCprofiler performs...
```{r}
require(devtools)
install_github("PedrioliLab/SECprofiler",ref="isa")
library('SECprofiler')
```

# Preparation
## Example data
PCprofiler is generally applicable to a variety of PCP-MS techniques. The examplary dataset used in this vignette is a subset of the peptide-level quantifitative matrix generated from HEK293 cell lysates by size-exclusion chromatography (SEC) coupled to SWATH-MS @REF. A total of 81 SEC fractions were sampled in consecutive order and each fraction was separately measured by SWATH-MS. The samples were analyzed employing a workflow consisting of OpenSWATH, pyProphet and TRIC @REF. A subset of the quantitative data matrix in long format is available within this package as ```{r, eval=FALSE}examplePCPdataLong``` and the annotation of which filename corresponds to which SEC fraction is available as ```{r, eval=FALSE}exampleFractionAnnotation```.
```{r, eval=TRUE}
pcpData <- examplePCPdataLong
fractionAnnotation <- exampleFractionAnnotation
```
## Input data
There are a variety of computational processing steps upstream of PCprofiler that are necessary to convert raw MS files to a matrix with quantitative values of different peptides or proteins across multiple PCP fractions. The functions available within PCprofiler assume that you have already generated such a quantitative peptide or protein matrix. 

### Quantitative PCP-MS data
The main input for PCprofiler is a quantitative peptide- or protein-level matrix in long or wide format. The necessary information are the protein_id and/or peptide_id, filename and intensity. 
```{r, eval=TRUE}
head(pcpData, n=2)
```
### Fraction annotation table
In addition to the quantitative PCP-MS data matrix, a mapping of the filenames to the consecutive fractions is necessary to generate elution profiles. It is important that the fractions start at 1 and consecutively increase by 1 unit until reaching the total number of fractions.
```{r, eval=TRUE}
head(fractionAnnotation, n=2)
```

### Molecular weight calibration
In some PCP techniques, such as size-exclusion chromatography, it is possible to map a separation fraction to a specific molecular weight. This can be done by standard proteins with known MW spiked in the samples or run separately on the fractionation device. These reference proteins can be used for molecular-weight calibration of the fractions for techniques where a log-linear relationship between fraction and molecular weight exists, for example size-excluson chromatography.
```{r, eval=TRUE, fig.show='hold'}
calibrationTable <- exampleCalibrationTable
calibrationTable
calibration = calibrateMW(calibrationTable, 
                             PDF=FALSE, 
                             plot=TRUE)
```

# Standard analysis workflow
## Import of elution profiles to traces object
The first step in any analysis with PCprofiler is the import of a quantitative peptide- or protein-level matrix in long or wide format that is converted to an object of class "traces". Levaraging the fraction annotation information, the traces data struncture includes a 
```{r, eval=TRUE, message=FALSE}
pepTraces <- importPCPdata(input_data=pcpData,
                          fraction_annotation=fractionAnnotation,
                          rm_decoys = FALSE)

## Trace annotation table
traceAnnotation <- exampleTraceAnnotation
head(traceAnnotation, n=2)
pepTraces <- annotateTraces(traces=pepTraces,
                            trace_annotation=traceAnnotation,
                            traces_id_column = "protein_id",
                            trace_annotation_id_column = "Entry",
                            trace_annotation_mass_column = "Mass",
                            uniprot_mass_format = TRUE,
                            replace_whitespace = TRUE)

summary(pepTraces)
```
## Quality control and filtering
* correct FDR estimation function
```{r, eval=TRUE, fig.show='hold'}
pepTraces_cons <- filterConsecutiveIdStretches(traces=pepTraces)
pepTraces_cons_sib <- filterBySibPepCorr(traces=pepTraces_cons,
                                         PDF=FALSE,
                                         plot=TRUE)
summary(pepTraces_cons_sib)
```
## Protein quantification
```{r, eval=TRUE}
protTraces <- proteinQuantification(pepTraces_cons_sib)
summary(protTraces)
```
## Protein feature finding
### Co-elution signal detection
* check improve write summary function for features
```{r, eval=TRUE, message=FALSE}
proteinFeatures <- findProteinFeatures(traces=pepTraces_cons_sib,
                                       calibration=calibration,
                                       parallelized=FALSE,
                                       useRandomDecoyModel=TRUE)
proteinFeatures_filtered <- subsetProteinFeatures(res=proteinFeatures,
                                                  min_subunits=3,
                                                  min_peak_corr=0.8)
head(proteinFeatures_filtered)
```
### FDR estimation
```{r,eval=TRUE}
proteinFeatures_stats <- estimateDecoyFDR(proteinFeatures_filtered)
```
## Complex feature finding
### Complex hypothesis generation
#### Targets
You can either load complex hypotheses in this format:
```{r,eval=TRUE}
complexHypotheses <- exampleComplexHypotheses
head(exampleComplexHypotheses)
```
Or generate complexes from an interacton network
* instead of generating binary interactions from hypotheses >> include example network ibn lazyLoad
```{r,eval=TRUE}
binaryHypotheses <- generateBinaryNetwork(complexHypotheses)
pathLength <- calculatePathlength(binaryHypotheses)
networkTargets <- generateComplexTargets(pathLength)
```

#### Decoys
* make sure the correct version of the decoy genertr is loaded & check decoy generation again (make faster?)
```{r,eval=FALSE}
networkHypotheses <- generateComplexDecoys(target_hypothesis=networkTargets,
                                           dist_info=pathLength,
                                           append=TRUE)
```
### Co-elution signal detection
```{r,eval=TRUE}
complexFeatures <- findComplexFeatures(traces=protTraces,
                                       complex_hypothesis = networkTargets,
                                       calibration = calibration,
                                       parallelized=FALSE)

complexFeatures_filtered <- subsetComplexFeatures(complexFeatures,min_peak_corr=0.5)
complexFeatures_filtered_best <- getBestComplexFeature(complexFeatures_filtered)
```
### FDR estimation
### Complex feature collapsing

# Visualization
## plotTraces
* include PDF option, include group by option
```{r, eval=TRUE, fig.show='hold'}
plot(protTraces)
```
## plotFeatures
* check for plotting function that takes any type of traces (pep and prot)
* plot once for peps and once for prots
```{r, eval=TRUE, fig.show='hold'}
plotComplexFeatures(res=complexFeatures_filtered,
                       proteinTraces=protTraces,
                       complexID = "1187",
                       calibration = calibration,
                       peak_area=TRUE)
```

## plot summarized MS coverage of complex hypotheses
* maybe rename function
```{r, eval=TRUE, fig.show='hold'}
plotSummarizedMScoverage(hypotheses=corumNetworkHypotheses,protTraces=protTraces)
```
## plot complex subfeature summary
```{r, eval=TRUE, fig.show='hold'}
plotComplexSubfeatureSummary(complexFeatures_bestParameterData)
```

# Parameter optimization
## Protein-level grid search
```{r, eval=FALSE}
proteinFeatures_grid <- performProteinGridSearch(traces=pepTraces_cons_sib,
                                                  calibration= calibration,
                                                  corrs = c(0.9,0.95),
                                                  windows = c(8),
                                                  smoothing = c(7),
                                                  rt_heights = c(3),
                                                  parallelized = TRUE,
                                                  n_cores=2)

proteinFeatures_grid_filtered <- filterGridSearchResults(proteinFeatures_grid,
                                                        peak_corr_cutoffs = c(0.5,0.75,0.9),
                                                        completeness_cutoffs = c(0,0.25,0.5,0.75),
                                                        n_subunits_cutoffs =c(2,3,4),
                                                        remove_decoys=FALSE
                                                        )

proteinFeatures_grid_filtered_stats <- estimateGridSearchDecoyFDR(proteinFeatures_grid_filtered)

proteinFeatures_bestParameterStats <- getBestParameterStats(stats=proteinFeatures_grid_filtered_stats,FDR=0.1)
proteinFeatures_bestParameterData <- getBestParameterData(proteinFeatures_grid_filtered)
```

## Complex-level grid search
```{r, eval=FALSE}
complexFeatures_grid <- performComplexGridSearch(traces=protTraces,
                                                complex_hypothesis=complexHypotheses,
                                                calibration=calibration,
                                                corrs = c(0.9,0.95),
                                                windows = c(8),
                                                smoothing = c(7),
                                                rt_heights = c(3),
                                                parallelized = TRUE,
                                                n_cores=2
                                                )

complexFeatures_grid_filtered <- filterGridSearchResults(complexFeatures_grid,
                                                        peak_corr_cutoffs = c(0.5,0.75,0.9),
                                                        completeness_cutoffs = c(0,0.25,0.5,0.75),
                                                        n_subunits_cutoffs =c(2,3,4),
                                                        remove_decoys=FALSE
                                                        )

complexFeatures_grid_filtered_stats <- estimateGridSearchDecoyFDR(complexFeatures_grid_filtered)

complexFeatures_bestParameterStats <- getBestParameterStats(stats=complexFeatures_grid_filtered_stats,FDR=0.1)
complexFeatures_bestParameterData <- getBestParameterData(complexFeatures_grid_filtered,FDR=0.1)

```



# Session information
```{r, val=TRUE, echo=FALSE}
session_info()
```

# References
