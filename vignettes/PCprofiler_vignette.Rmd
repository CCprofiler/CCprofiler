---
title: "Introduction to the PCprofiler package"
author: "Isabell Bludau, Max Frank"
date: '`r Sys.Date()`'
output:
  html_document:
    depth: 3
    number_sections: yes
    theme: united
    toc: yes
  pdf_document:
    toc: yes
vignette: |
  %\VignetteIndexEntry{Introduction to the PCprofiler package} %\VignetteEngine{knitr::rmarkdown} %\VignetteEncoding{UTF-8}
---

# Overview
Here we show the basic steps for performing the analysis of PCP-MS datasets with PCprofiler. PCprofiler performs...
```{r}
require(devtools)
install_github("PedrioliLab/SECprofiler",ref="isa")
library('SECprofiler')
```

# Preparation
## Example data
PCprofiler is generally applicable to a variety of PCP-MS techniques. The examplary dataset used in this vignette is a subset of the peptide-level quantifitative matrix generated from HEK293 cell lysates by size-exclusion chromatography (SEC) coupled to SWATH-MS @REF. A total of 81 SEC fractions were sampled in consecutive order and each fraction was separately measured by SWATH-MS. The samples were analyzed employing a workflow consisting of OpenSWATH, pyProphet and TRIC @REF. A subset of the quantitative data matrix in long format is available within this package as ```{r, eval=FALSE}examplePCPdataLong``` and the annotation of which filename corresponds to which SEC fraction is available as ```{r, eval=FALSE}exampleFractionAnnotation```.
```{r, eval=TRUE}
pcpData <- examplePCPdataLong
fractionAnnotation <- exampleFractionAnnotation
```
## Input data
There are a variety of computational processing steps upstream of PCprofiler that are necessary to convert raw MS files to a matrix with quantitative values of different peptides or proteins across multiple PCP fractions. The functions available within PCprofiler assume that you have already generated such a quantitative peptide or protein matrix. 

### Quantitative PCP-MS data
The main input for PCprofiler is a quantitative peptide- or protein-level matrix in long or wide format. The necessary information are the protein_id and/or peptide_id, filename and intensity. 
```{r, eval=TRUE}
head(pcpData, n=2)
```
### Fraction annotation table
In addition to the quantitative PCP-MS data matrix, a mapping of the filenames to the consecutive fractions is necessary to generate elution profiles. It is important that the fractions start at 1 and consecutively increase by 1 unit until reaching the total number of fractions.
```{r, eval=TRUE}
head(fractionAnnotation, n=2)
```

### Molecular weight calibration
In some PCP techniques, such as size-exclusion chromatography, it is possible to map a separation fraction to a specific molecular weight. This can be done by standard proteins with known MW spiked in the samples or run separately on the fractionation device. These reference proteins can be used for molecular-weight calibration of the fractions for techniques where a log-linear relationship between fraction and molecular weight exists, for example size-excluson chromatography.
```{r, eval=TRUE, fig.show='hold'}
calibrationTable <- exampleCalibrationTable
calibrationTable
calibration = calibrateMW(calibrationTable, 
                             PDF=FALSE, 
                             plot=TRUE)
```

# Standard analysis workflow
## Import of elution profiles to traces object
The first step in any analysis with PCprofiler is the import of a quantitative peptide- or protein-level matrix in long or wide format that is converted to an object of class "traces". Levaraging the fraction annotation information, the traces data struncture includes a 
```{r, eval=TRUE, message=FALSE}
## Import quantitative PCP data into a traces object
pepTraces <- importPCPdata(input_data=pcpData,
                          fraction_annotation=fractionAnnotation,
                          rm_decoys = FALSE)

## Trace annotation table
traceAnnotation <- exampleTraceAnnotation
head(traceAnnotation, n=2)

## Annotate traces with information from uniprot
pepTraces <- annotateTraces(traces=pepTraces,
                            trace_annotation=traceAnnotation,
                            traces_id_column = "protein_id",
                            trace_annotation_id_column = "Entry",
                            trace_annotation_mass_column = "Mass",
                            uniprot_mass_format = TRUE,
                            replace_whitespace = TRUE)

## Annotate traces with molecular weight calibration (if applicable)
pepTraces <- annotateMolecularWeight(examplePeptideTraces,calibration)

## Inspect resulting annotated traces object
summary(pepTraces)
```
## Quality control and filtering
```{r, eval=TRUE, fig.show='hold'}
## Filter by 3 consecutive ids
pepTraces_cons <- filterConsecutiveIdStretches(traces=pepTraces, 
                                               min_stretch_length = 3)
## Filter by 0.2 sibling peptide correlation
## Note that instead of a fixed "absolute_spcCutoff" an fdr cutoff can be specified. 
## The sibling peptide correlation cutoff will theb be chosen to result in the specified 
## FDR as estimated by decoy counting. 
pepTraces_cons_sib <- filterBySibPepCorr(traces=pepTraces_cons,
                                         fdr_cutoff = NULL, 
                                         absolute_spcCutoff = 0.2, 
                                         plot=TRUE)

summary(pepTraces_cons_sib)
```
## Protein quantification
```{r, eval=TRUE}
protTraces <- proteinQuantification(pepTraces_cons_sib, 
                                    topN = 2,
                                    keep_less = FALSE,
                                    rm_decoys = TRUE)
summary(protTraces)
```
## Protein feature finding
### Co-elution signal detection
```{r, eval=TRUE, message=FALSE}
testProteins = unique(pepTraces_cons_sib$trace_annotation$protein_id)[1:10]
peptideTracesSubset = subset(pepTraces_cons_sib,trace_subset_ids = testProteins, trace_subset_type = "protein_id")
proteinFeatures <- findProteinFeatures(traces = peptideTracesSubset,
                                       useRandomDecoyModel = TRUE)
proteinFeaturesFiltered <- filterFeatures(feature_table = proteinFeatures,
                                          min_feature_completeness = 0.5,
                                          min_peak_corr = 0.5)
summarizeFeatures(proteinFeaturesFiltered)
```
### FDR estimation
```{r,eval=TRUE}
estimateDecoyFDR(proteinFeaturesFiltered)
```
## Complex feature finding
### Complex hypothesis generation
#### Targets
You can either load complex hypotheses in this format:
```{r,eval=TRUE}
complexHypotheses <- exampleComplexHypotheses
head(exampleComplexHypotheses)
```
Or generate complexes from an interacton network
* instead of generating binary interactions from hypotheses >> include example network ibn lazyLoad
```{r,eval=TRUE}
binaryHypotheses <- generateBinaryNetwork(complexHypotheses)
pathLength <- calculatePathlength(binaryHypotheses)
networkTargets <- generateComplexTargets(pathLength)
```

#### Decoys
```{r,eval=FALSE}
## Generate decoys for complex hypotheses as provided in CORUM DB
## Small sample complex sets as used in previous examples are too small for decoy generation.
corumTargetsPlusDecoys <- generateComplexDecoys(target_hypotheses=corumComplexHypotheses,
                                                  dist_info=pathLength,
                                                  min_distance = 2,
                                                  append=TRUE)
```
### Co-elution signal detection
```{r,eval=TRUE}
complexFeatures <- findComplexFeatures(traces=protTraces,
                                       complex_hypothesis = complexHypotheses)
complexFeaturesFiltered <- filterFeatures(feature_table = complexFeatures,
                                          min_feature_completeness = 0.5,
                                          min_peak_corr = 0.5)
summarizeFeatures(complexFeaturesFiltered)

bestComplexFeaturesFiltered <- getBestFeatures(complexFeaturesFiltered)
summarizeFeatures(bestComplexFeaturesFiltered)
```
### FDR estimation
```{r,eval=TRUE}
estimateDecoyFDR(bestComplexFeaturesFiltered)
```
### Complex feature collapsing
```{r,eval=TRUE}
complexFeaturesUnique <- getUniqueFeatureGroups(complexFeaturesFiltered,
                                                rt_height=2,
                                                distance_cutoff=1)
complexFeaturesCollapsed <- callapseByUniqueFeatureGroups(complexFeaturesUnique,
                                                            rm_decoys=TRUE)
```
# Visualization
## plotTraces
```{r, eval=TRUE, fig.show='hold'}
plot(protTraces,
     legend = FALSE)
```
## plotFeatures
```{r, eval=TRUE, fig.show='hold'}
plotComplexFeatures(feature_table = complexFeaturesFiltered,
                       traces = protTraces,
                       feature_id = "1187",
                       calibration = calibration,
                       peak_area = TRUE)

plotComplexFeatures(feature_table = proteinFeaturesFiltered,
                       traces = pepTraces_cons_sib,
                       feature_id = "Q86VN1",
                       calibration = calibration,
                       peak_area = TRUE)
```

## plot summarized MS coverage of complex hypotheses
* maybe rename function
```{r, eval=TRUE, fig.show='hold'}
plotSummarizedMScoverage(hypotheses=corumNetworkHypotheses,protTraces=protTraces)
```
## plot complex subfeature summary
```{r, eval=TRUE, fig.show='hold'}
plotComplexSubfeatureSummary(complexFeatures_bestParameterData)
```

# Parameter optimization
## Protein-level grid search
```{r, eval=FALSE}
proteinFeatures_grid <- performProteinGridSearch(traces=pepTraces_cons_sib,
                                                  calibration= calibration,
                                                  corrs = c(0.9,0.95),
                                                  windows = c(8),
                                                  smoothing = c(7),
                                                  rt_heights = c(3),
                                                  parallelized = TRUE,
                                                  n_cores=2)

proteinFeatures_grid_filtered <- filterGridSearchResults(proteinFeatures_grid,
                                                        peak_corr_cutoffs = c(0.5,0.75,0.9),
                                                        completeness_cutoffs = c(0,0.25,0.5,0.75),
                                                        n_subunits_cutoffs =c(2,3,4),
                                                        remove_decoys=FALSE
                                                        )

proteinFeatures_grid_filtered_stats <- estimateGridSearchDecoyFDR(proteinFeatures_grid_filtered)

proteinFeatures_bestParameterStats <- getBestParameterStats(stats=proteinFeatures_grid_filtered_stats,FDR=0.1)
proteinFeatures_bestParameterData <- getBestParameterData(proteinFeatures_grid_filtered)
```

## Complex-level grid search
```{r, eval=FALSE}
complexFeatures_grid <- performComplexGridSearch(traces=protTraces,
                                                complex_hypothesis=complexHypotheses,
                                                calibration=calibration,
                                                corrs = c(0.9,0.95),
                                                windows = c(8),
                                                smoothing = c(7),
                                                rt_heights = c(3),
                                                parallelized = TRUE,
                                                n_cores=2
                                                )

complexFeatures_grid_filtered <- filterGridSearchResults(complexFeatures_grid,
                                                        peak_corr_cutoffs = c(0.5,0.75,0.9),
                                                        completeness_cutoffs = c(0,0.25,0.5,0.75),
                                                        n_subunits_cutoffs =c(2,3,4),
                                                        remove_decoys=FALSE
                                                        )

complexFeatures_grid_filtered_stats <- estimateGridSearchDecoyFDR(complexFeatures_grid_filtered)

complexFeatures_bestParameterStats <- getBestParameterStats(stats=complexFeatures_grid_filtered_stats,FDR=0.1)
complexFeatures_bestParameterData <- getBestParameterData(complexFeatures_grid_filtered,FDR=0.1)

```



# Session information
```{r, val=TRUE, echo=FALSE}
session_info()
```

# References
