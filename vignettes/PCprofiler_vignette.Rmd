---
title: "Introduction to the CCprofiler package"
author: "Isabell Bludau, Max Frank, Moritz Heusel"
date: '`r Sys.Date()`'
output:
  html_document:
    depth: 3
    number_sections: yes
    theme: united
    toc: yes
  pdf_document:
    toc: yes
fontsize: 11pt
vignette: |
  %\VignetteIndexEntry{Introduction to the CCprofiler package} %\VignetteEngine{knitr::rmarkdown} %\VignetteEncoding{UTF-8}
---
\let\oldShaded\Shaded
\let\endoldShaded\endShaded
\renewenvironment{Shaded}{\footnotesize\oldShaded}{\endoldShaded}
\let\oldverbatim\verbatim
\let\endoldverbatim\endverbatim
\renewenvironment{verbatim}{\footnotesize\oldverbatim}{\endoldverbatim}

# Overview
Here we present the basic functionalities of the package CCprofiler for complex-centric co-fractionation MS data analysis.

```{r, message=FALSE, warning=FALSE, cache=FALSE}
require(devtools)
install_github("PedrioliLab/SECprofiler", ref = "submission")
library('SECprofiler')
```

# Preparation
## Example data
CCprofiler is generically applicable to data sets generated by co-fractionation MS techniques. The exemplary data set used in this vignette is a subset of the peptide-level quantitative matrix generated from HEK293 cells analyzed by SEC-SWATH-MS @REF. A total of 81 SEC fractions were sampled in consecutive order and each fraction was separately measured by SWATH-MS. The samples were analyzed employing a workflow consisting of OpenSWATH, pyProphet and TRIC @REF. A subset of the quantitative data matrix in long format is available within this package as ```examplePCPdataLong``` and the annotation of which filename corresponds to which SEC fraction is available as ```exampleFractionAnnotation```.

```{r, eval=TRUE}
pcpData <- examplePCPdataLong
fractionAnnotation <- exampleFractionAnnotation
```

## Input data
There are a variety of computational processing steps upstream of CCprofiler that are necessary to convert raw MS files to a matrix with quantitative values of the detected peptides or proteins across all acquired fractions. The functions available within CCprofiler require that you have already generated such a quantitative peptide or protein matrix. 

### Quantitative co-fractionation MS data
The main input for CCprofiler is a quantitative peptide- or protein-level matrix in long or wide format. The necessary information are the protein_id and/or peptide_id, filename and intensity. 

```{r, eval=TRUE}
head(pcpData, n = 2)
```

### Fraction annotation table
In addition to the quantitative co-fractionation MS data matrix, a mapping of the filenames to the consecutively measured fractions is necessary to generate elution profiles. It is important that the fractions start at 1 and consecutively increase by 1 unit until reaching the total number of fractions.

```{r, eval=TRUE}
head(fractionAnnotation, n = 2)
```

### Molecular weight calibration
In some co-fractionation techniques, such as size-exclusion chromatography, a log-linear relationship between the fraction dimension and molecular weight (MW) can be assumed. In such cases a MW calibration is possible by leveraging the elution information of standard proteins with known MWs spiked into the samples or run separately on the fractionation device. An example MW calibration table is available as ```exampleCalibrationTable```.

```{r, eval=TRUE, fig.show='hold'}
calibrationTable <- exampleCalibrationTable
calibrationTable
calibration = calibrateMW(calibrationTable)
```

# Standard analysis workflow
## Import of elution profiles to traces object
The first step in any analysis with CCprofiler is the import of a quantitative peptide- or protein-level matrix in long or wide format that is converted to an object of class "traces". Leveraging the fraction annotation information, the traces data structure is a list containing four items:

* A traces data.table containing quantitative profiles of the peptides or proteins. Each row represents a peptide or protein while the columns are the consecutive fractions and a final column with the id specification of the row. 
* A trace_type character specifying whether the trace is of type "peptide" or "protein".
* A trace_annotation data.table containing information for each peptide or protein, e.g. molecular weight.
* A fraction annotation data.table containing fraction information, e.g. the sample name of each fraction.

The trace annotation can be extended with additional information from databases such as UniProt (```exampleTraceAnnotation```). Finally each fraction can be mapped to its estimated molecular weight as determined by a calibration function. Although helpful for biological interpretation of the results, the general functionalities of CCprofiler do not depend on the additional trace and molecular weight annotation steps.

```{r, eval=TRUE, message=FALSE}
## Import quantitative PCP data into a traces object
pepTraces <- importPCPdata(input_data = pcpData,
                           fraction_annotation = fractionAnnotation,
                           rm_decoys = FALSE)

## Trace annotation table
traceAnnotation <- exampleTraceAnnotation
head(traceAnnotation, n = 2)

## Annotate traces with information from uniprot
pepTraces <- annotateTraces(traces = pepTraces,
                            trace_annotation = traceAnnotation,
                            traces_id_column = "protein_id",
                            trace_annotation_id_column = "Entry",
                            trace_annotation_mass_column = "Mass",
                            uniprot_mass_format = TRUE,
                            replace_whitespace = TRUE)

## Annotate traces with molecular weight calibration (if applicable)
pepTraces <- annotateMolecularWeight(examplePeptideTraces, 
                                     calibration)

## Inspect resulting annotated traces object
summary(pepTraces)
```

## Quality control and filtering
CCprofiler includes several options to filter for low-quality data points and noisy traces in the data. The first option is to filter the data points within a peptide trace based on consecutive identifications. A minimum stretch length of 3 means that intensity values that are not embedded in a row of at least 3 consecutive identifications are removed (i.e. set to zero). A second filter based on sibling peptide correlation calculates the mean sibling peptide correlation of each peptide to its sibling peptides. Peptides with a low sibling peptide correlation can be removed either by a fixed cutoff or by selecting an FDR cutoff that should be reached after the filtering.

```{r, eval=TRUE, fig.show='hold'}
## Filter by 3 consecutive ids
pepTraces_cons <- filterConsecutiveIdStretches(traces = pepTraces, 
                                               min_stretch_length = 3)
## Filter by 0.2 sibling peptide correlation
## Note that instead of a fixed "absolute_spcCutoff" an fdr cutoff can be specified. 
## The sibling peptide correlation cutoff will then be chosen to result in the specified 
## FDR as estimated by decoy counting. 
pepTraces_cons_sib <- filterBySibPepCorr(traces = pepTraces_cons,
                                         fdr_cutoff = NULL, 
                                         absolute_spcCutoff = 0.2, 
                                         plot = TRUE)

summary(pepTraces_cons_sib)
```

## Protein quantification
The peptide traces can be used to infer protein-level traces. CCprofiler implements a topN strategy for summarizing peptides to a protein trace. Decoys should typically be removed at this stage.

```{r, eval=TRUE}
protTraces <- proteinQuantification(pepTraces_cons_sib, 
                                    topN = 2,
                                    keep_less = FALSE,
                                    rm_decoys = TRUE)
summary(protTraces)
```

## Protein feature finding
Protein feature finding consists of two consecutive steps: (i) co-elution signal detection followed by (ii) statistical scoring, FDR estimation and filtering. 

### Co-elution signal detection
Protein features are determined by a sliding window strategy, where all peptides of a protein are tested for local profile correlation. If a subset of the peptides within a protein correlate better then the specified cutoff, a protein feature is initiated, followed by peak detection within the regions of high correlation. Here we perform the protein feature finding only on a subset of all proteins because this can take some time. In order to be able to estimate an error-rate, protein decoys can be generated on the fly during the feature detection step by randomly assigning peptides to a protein decoy (```useRandomDecoyModel = TRUE```).

```{r, eval=TRUE, message=FALSE, warning=FALSE, cache=FALSE, results='hide'}
testProteins = unique(pepTraces_cons_sib$trace_annotation$protein_id)[1:20]
peptideTracesSubset = subset(pepTraces_cons_sib,
                             trace_subset_ids = testProteins, 
                             trace_subset_type = "protein_id")
proteinFeatures <- findProteinFeatures(traces = peptideTracesSubset,
                                       useRandomDecoyModel = TRUE)
```

```{r, eval=TRUE, message=FALSE, warning=FALSE, cache=FALSE}
head(proteinFeatures, n = 2)
```

### Statistical scoring, FDR estimation and filtering

The resulting protein features can be scored based on the co-elution characteristics (average peptide correlation) of the peptides within each protein feature. The co-elution score is further statistcally corrected for the number of correlating peptides out of all the MS detectable peptides @REF. The statistically corrected co-elution score can be used to estimate q-values for each protein peak group @REF. Filtering the protein peak groups based on a specified q-value cutoff then achieves a final result table at specified FDR (a q-value cutoff of 0.05 results in a final table with 5% FDR). 

```{r, eval=TRUE, message=FALSE, warning=FALSE, cache=FALSE, fig.width=6, fig.align='center'}
proteinFeaturesScored <- calculateCoelutionScore(proteinFeatures)
qvalueProteinFeaturesScored <- calculateQvalue(proteinFeaturesScored)
qvalueProteinFeaturesScoredStats <- qvaluePositivesPlot(qvalueProteinFeaturesScored)
proteinFeaturesFiltered <- subset(qvalueProteinFeaturesScored, qvalue <= 0.05)
summarizeFeatures(proteinFeaturesFiltered)
```

## Complex feature finding

### Complex hypothesis generation
In general the complex feature detection is very similar to the protein feature detection with the difference that complex hypotheses have to be generated at the beginning. This includes both target and decoy complex hypotheses for error estimation. 

#### Targets
There are two options for protein complex target generation in CCprofiler: (i) loading of concrete hypotheses or (ii) loading a protein-protein interaction network from which target complex hypotheses can be extracted. The use of concrete complex hypotheses requires loading a complex hypothesis table in the following format:

```{r,eval=TRUE}
complexHypotheses <- exampleComplexHypotheses
head(complexHypotheses)
```

Alternatively target complex hypotheses can be generated from a binary protein interaction network by grouping each proteins with their neighboys. In this example, we first generate a binary interaction network from the example hypotheses generated above. In a real world example you could for example load data from Bioplex or StringDB. The distance between any protein pair in the network is then calculated and used for generating network-based targets.

```{r,eval=TRUE}
binaryHypotheses <- generateBinaryNetwork(complexHypotheses)
pathLength <- calculatePathlength(binaryHypotheses)
networkTargets <- generateComplexTargets(pathLength)
head(networkTargets)
```

#### Decoys

Complex hypothesis decoys are generated based on the target hypothesis set and its underlying network structure. The minimum distance specifies the minimal number of edges between any two proteins within any generated decoy complex hypothesis. It is important that the interacton network based on the targets is large enough to generate a random decoy set that does not overlap with the target hypotheses. We recommend hypothesis sets of at least 1000 targets for the decoy based approach. 

```{r,eval=FALSE}
corumTargetsPlusDecoys <- generateComplexDecoys(target_hypotheses=corumComplexHypotheses,
                                                dist_info=pathLength,
                                                min_distance = 2,
                                                append=TRUE)
```

### Co-elution signal detection

Protein complex features are determined similar to the protein features described above. First, a sliding window strategy is applied, where all proteins of a protein complex hypothesis are tested for local profile correlation. If a subset of the proteins within a protein complex hypothesis correlate better then the specified cutoff, a protein complex feature is initiated, followed by peak detection within the regions of high correlation. 

```{r, eval=TRUE, message=FALSE, warning=FALSE, cache=FALSE, results='hide',fig.width=6, fig.align='center'}
complexFeatures <- findComplexFeatures(traces=protTraces,
                                       complex_hypothesis = complexHypotheses)
```

Sometimes it might is beneficial to only report the 'best' (largest numer of co-eluting protein subunits) detected complex co-elution peak group. 

```{r, eval=TRUE, message=FALSE, warning=FALSE, cache=FALSE}
complexFeaturesBest <- getBestFeatures(complexFeatures)
```

Additionally, complex (and also protein) feature results can be filtered by different criteria. For example, if information abount the molecular weight of each measured fraction is available, one can filter out complex features that elute at a molecular weight that is lower than a certain threshold with respect to the expected monomer elution fraction (based on the molecular weights of the protein monomer molecular weights).

```{r, eval=TRUE, message=FALSE, warning=FALSE, cache=FALSE}
complexFeaturesFilteredMW <- filterFeatures(complexFeatures,
                                            complex_ids = NULL,
                                            protein_ids = NULL,
                                            min_feature_completeness = NULL,
                                            min_hypothesis_completeness = NULL,
                                            min_subunits = NULL,
                                            min_peak_corr = NULL,
                                            min_monomer_distance_factor = 2
                                            )
```

### Statistical scoring, FDR estimation and filtering

The resulting protein complex features can be scored based on the co-elution characteristics (average protein subunit correlation) of the proteins within each protein complex feature. The co-elution score is further statistcally corrected for the number of correlating proteins out of all the proteins in the protein complex hypothesis. The statistically corrected co-elution score can be used to estimate q-values for each protein complex peak group @REF. Filtering the protein complex peak groups based on a specified q-value cutoff then achieves a final result table at specified FDR (a q-value cutoff of 0.05 results in a final table with 5% FDR). 

```{r, eval=TRUE, message=FALSE, warning=FALSE, cache=FALSE, fig.width=6, fig.align='center'}
complexFeaturesScored <- calculateCoelutionScore(complexFeatures)
qvalueComplexFeaturesScored <- calculateQvalue(complexFeaturesScored)
head(qvalueComplexFeaturesScored, n = 2)
qvalueComplexFeaturesScoredStats <- qvaluePositivesPlot(qvalueComplexFeaturesScored)
complexFeaturesFiltered <- subset(qvalueComplexFeaturesScored, qvalue <= 0.05)
summarizeFeatures(complexFeaturesFiltered)
```

### Complex feature collapsing

Notably, CCprofiler is able to retrieve co-elution evidence from full protein complex hypotheses but also subsets thereof. Due to partial overlap of the protein sets grouped as hypotheses, the same co-elution signal can be retrieved as evidence for multiple different hypotheses. Thus, we collapse the initial results to truly unique signals with regard to (i), subunit composition and (ii), resolution in the chromatographic dimension.

```{r,eval=TRUE}
complexFeaturesUnique <- getUniqueFeatureGroups(complexFeaturesFiltered,
                                                rt_height = 0,
                                                distance_cutoff = 1.25)
complexFeaturesCollapsed <- callapseByUniqueFeatureGroups(complexFeaturesUnique,
                                                          rm_decoys = TRUE)
```

# Visualization

CCprofiler offers multiple functions to visualize the data and results.

## Peptide or protein trace visualization

Traces objects in CCproiler can be plotted at different stages during data processing to get a feeling for the data structure and chromatographic beaviour of different peptides or proteins. 

```{r, eval=TRUE, fig.show='hold',fig.width=6, fig.align='center'}
plot(protTraces,
     legend = FALSE)
```

## Protein and protein complex co-elution feature visualization

Detected protein features (peptide co-elution peak groups) and/or protein complex features (protein subunit co-elution peak groups) can be visualized with ```plotFeatures```.

```{r, eval=TRUE, fig.show='hold',fig.width=6, fig.align='center'}
plotFeatures(feature_table = proteinFeaturesFiltered,
             traces = pepTraces_cons_sib,
             feature_id = "P61201",
             calibration = calibration,
             peak_area = TRUE,
             legend = FALSE)
```

```{r, eval=TRUE, fig.show='hold',fig.width=6, fig.align='center'}
plotFeatures(feature_table = complexFeaturesFiltered,
             traces = protTraces,
             feature_id = "1187",
             annotation_label="Entry_name",
             calibration = calibration,
             peak_area = TRUE)
```

## Visualization of the MS coverage of all tested complex hypotheses

The MS coverage of all tested complex hypotheses can be inspected to gain an impression of how well your hypothesis set is represented my the MS measurements without taing co-elution information into account.

```{r, eval=TRUE, fig.show='hold',fig.width=6, fig.align='center', message=FALSE, warning=FALSE, results='hide'}
plotSummarizedMScoverage(hypotheses = complexHypotheses,
                         protTraces = protTraces)
```

## Visualization of fully and partially observed complex hypotheses

```{r, eval=TRUE, fig.show='hold',fig.width=6, fig.align='center', results='hide'}
plotSummarizedComplexes(complexFeatures = complexFeaturesFiltered, 
                        hypotheses = complexHypotheses, 
                        protTraces = protTraces)
```

```{r, eval=TRUE, fig.show='hold',fig.width=6, fig.align='center'}
plotComplexCompletenessScatter(complexFeatures = complexFeaturesFiltered)
```

# Parameter optimization

A grid search can be performed to determine an optimal set of parameters for the protein- and/or complex-centric proteome profiling workflow. This optimal parameter set depends mostly on the co-fractionation characteristics and MS setup.  

## Protein-level grid search

```{r, eval=FALSE}
proteinFeatures_grid <- performProteinGridSearch(traces = peptideTracesSubset,
                                                 corrs = c(0.5,0.9),
                                                 windows = c(10),
                                                 smoothing = c(7),
                                                 rt_heights = c(4),
                                                 n_cores = 2)

proteinFeatures_scoredData <- lapply(proteinFeatures_grid, calculateCoelutionScore)
proteinFeatures_qvalueData <- lapply(proteinFeatures_scoredData, calculateQvalue, plot=F)
proteinFeatures_stats <- qvaluePositivesPlotGrid(proteinFeatures_qvalueData)
proteinFeatures_bestStats <- getBestQvalueParameters(proteinFeatures_stats, FDR_cutoff = 0.05)
proteinFeatures_bestStats
```

## Complex-level grid search

```{r, eval=FALSE}
complexFeatures_grid <- performComplexGridSearch(traces = protTraces,
                                                 complex_hypothesis = complexHypotheses,
                                                 corrs = c(0.9,0.95),
                                                 windows = c(10),
                                                 smoothing = c(7),
                                                 rt_heights = c(4),
                                                 n_cores = 2
                                                 )

complexFeatures_scoredData <- lapply(complexFeatures_grid, calculateCoelutionScore)
complexFeatures_qvalueData <- lapply(complexFeatures_scoredData, calculateQvalue, plot=F)
complexFeatures_stats <- qvaluePositivesPlotGrid(complexFeatures_qvalueData)
complexFeatures_bestStats <- getBestQvalueParameters(complexFeatures_stats, FDR_cutoff = 0.05)
complexFeatures_bestStats
```

# Session information

```{r, val=TRUE, echo=FALSE}
session_info()
```

# References
